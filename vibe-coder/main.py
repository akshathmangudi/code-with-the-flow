import asyncio
from typing import Annotated
import os
import re
from dotenv import load_dotenv
from fastmcp import FastMCP
from fastmcp.server.auth.providers.bearer import BearerAuthProvider, RSAKeyPair
from mcp import ErrorData, McpError
from mcp.server.auth.provider import AccessToken
from mcp.types import TextContent, INVALID_PARAMS, INTERNAL_ERROR
from pydantic import BaseModel, Field

# --- Load environment variables ---
load_dotenv()

TOKEN = os.environ.get("PUCH_AI_API_KEY", "28faaaa48cb3")
MY_NUMBER = os.environ.get("MY_NUMBER", "918106200629")

assert TOKEN is not None, "Please set PUCH_AI_API_KEY in your .env file"
assert MY_NUMBER is not None, "Please set MY_NUMBER in your .env file"

# --- Auth Provider ---
class SimpleBearerAuthProvider(BearerAuthProvider):
    def __init__(self, token: str):
        k = RSAKeyPair.generate()
        super().__init__(public_key=k.public_key, jwks_uri=None, issuer=None, audience=None)
        self.token = token

    async def load_access_token(self, token: str) -> AccessToken | None:
        if token == self.token:
            return AccessToken(
                token=token,
                client_id="puch-client",
                scopes=["*"],
                expires_at=None,
            )
        return None

# --- Rich Tool Description model ---
class RichToolDescription(BaseModel):
    description: str
    use_when: str
    side_effects: str | None = None

# --- Utility Functions ---
def sanitize_prompt_for_directory(prompt: str) -> str:
    """Sanitizes a prompt to be used as a directory name."""
    # Remove "code a" or "create a" prefixes
    prompt = re.sub(r'^(code|create)\s+a(n)?\s+', '', prompt, flags=re.IGNORECASE)
    # Replace spaces and special characters with hyphens
    s = prompt.lower().strip()
    s = re.sub(r'[\s\W]+', '-', s)
    # Remove trailing hyphens
    s = s.strip('-')
    return s if s else "unnamed-app"

# --- MCP Server Setup ---
mcp = FastMCP(
    "Vibe Coder MCP Server",
    auth=SimpleBearerAuthProvider(TOKEN),
)

# --- Tool: validate (required by Puch) ---
@mcp.tool
async def validate() -> str:
    """Required validate tool that returns your phone number in {country_code}{number} format."""
    return MY_NUMBER

# --- Tool: code_app (vibe-coding functionality) ---
CodeAppDescription = RichToolDescription(
    description="Create a Flask web application based on a user's prompt or description.",
    use_when="Use this when the user wants to create a web application, app, or any coding project.",
    side_effects="Creates a new project directory with Flask application, requirements.txt, README.md, and .env files.",
)

@mcp.tool(description=CodeAppDescription.model_dump_json())
async def code_app(
    prompt: Annotated[str, Field(description="The prompt describing the app to create")],
) -> str:
    """Codes an app based on the provided prompt."""
    project_name = sanitize_prompt_for_directory(prompt)
    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', project_name))

    if os.path.exists(project_dir):
        return f"‚ùå Error: A project named '{project_name}' already exists."

    try:
        os.makedirs(project_dir)

        # Create requirements.txt
        requirements_path = os.path.join(project_dir, 'requirements.txt')
        with open(requirements_path, 'w') as f:
            f.write('Flask==3.0.0\nrequests==2.31.0\npython-dotenv==1.0.0\n')

        # Create app.py with enhanced structure
        app_py_path = os.path.join(project_dir, 'app.py')
        app_py_content = f'''from flask import Flask, render_template, request, jsonify
import os
from dotenv import load_dotenv

load_dotenv()

app = Flask(__name__)

@app.route('/')
def hello_world():
    return f'<h1>Hello from {project_name}!</h1><p>Your app is running successfully!</p>'

@app.route('/api/health')
def health_check():
    return jsonify({{"status": "healthy", "app": "{project_name}"}})

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(debug=True, host='0.0.0.0', port=port)
'''
        with open(app_py_path, 'w') as f:
            f.write(app_py_content)

        # Create README.md
        readme_path = os.path.join(project_dir, 'README.md')
        readme_content = f'''# {project_name}

This application was created using Vibe Coder with Puch AI.

## Features
- Flask web application
- Health check endpoint
- Environment variable support

## Running the app

1. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

2. Run the application:
   ```bash
   python app.py
   ```

3. Visit http://localhost:5000

## API Endpoints

- `GET /` - Main page
- `GET /api/health` - Health check

Generated by Vibe Coder ü§ñ
'''
        with open(readme_path, 'w') as f:
            f.write(readme_content)

        # Create .env file
        env_path = os.path.join(project_dir, '.env')
        with open(env_path, 'w') as f:
            f.write(f'APP_NAME={project_name}\nPORT=5000\n')

        return f"‚úÖ Successfully created Flask project '{project_name}' in {project_dir}"

    except Exception as e:
        return f"‚ùå An error occurred: {e}"

# --- Tool: validate_project (project validation) ---
ValidateProjectDescription = RichToolDescription(
    description="Validate a created project for syntax errors and requirements.",
    use_when="Use this to check if a created project has all required files and valid syntax.",
    side_effects="Returns validation results showing what files exist and if syntax is valid.",
)

@mcp.tool(description=ValidateProjectDescription.model_dump_json())
async def validate_project(
    project_name: Annotated[str, Field(description="The name of the project to validate")],
) -> str:
    """Validate the created project for syntax errors and requirements."""
    project_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', project_name))
    
    if not os.path.exists(project_dir):
        return f"‚ùå Project '{project_name}' not found."
    
    try:
        validation_results = []
        
        # Check if app.py exists
        app_py_path = os.path.join(project_dir, 'app.py')
        if os.path.exists(app_py_path):
            validation_results.append("‚úÖ app.py exists")
        else:
            validation_results.append("‚ùå app.py missing")
        
        # Check if requirements.txt exists
        requirements_path = os.path.join(project_dir, 'requirements.txt')
        if os.path.exists(requirements_path):
            validation_results.append("‚úÖ requirements.txt exists")
        else:
            validation_results.append("‚ùå requirements.txt missing")
        
        # Check if README.md exists
        readme_path = os.path.join(project_dir, 'README.md')
        if os.path.exists(readme_path):
            validation_results.append("‚úÖ README.md exists")
        else:
            validation_results.append("‚ùå README.md missing")
        
        # Test Python syntax
        try:
            with open(app_py_path, 'r') as f:
                compile(f.read(), app_py_path, 'exec')
            validation_results.append("‚úÖ Python syntax is valid")
        except SyntaxError as e:
            validation_results.append(f"‚ùå Python syntax error: {e}")
        
        validation_summary = "\\n".join(validation_results)
        return f"Validation Results:\\n{validation_summary}"
        
    except Exception as e:
        return f"‚ùå Validation failed: {e}"

# --- Run MCP Server ---
async def main():
    print("üöÄ Starting Vibe Coder MCP server on http://0.0.0.0:8000")
    await mcp.run_async("streamable-http", host="0.0.0.0", port=8000)

if __name__ == "__main__":
    asyncio.run(main())
